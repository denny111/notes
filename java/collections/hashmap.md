# hashmap 

## 散列表

### 直接寻址

用一个数组，或称为直接寻址表，使用元素关键字作为数组下标进行寻址。

### 散列表

直接寻址如果全域很大，则需要在开始时即开辟非常大的内存空间，且实际存储时内存空间大部分被浪费。

直接寻址中，关键字为k的元素存放在槽k中。在散列方式下，该元素存放在h(k)，即利用散列函数h，由关键字k计算出存放的位置。

存在一个情况：两个元素的h(k)相同，即映射到了一个槽上，称这种情况为冲突。

一方面可以通过精心设计的散列函数来尽量减少冲突的次数，另一方面仍需要有解决可能出现冲突的方法。

两种方法：链接法（后面介绍的hashmap即采用这种方法），开放寻址法。

### 链接法

链接法即把散列到同一个槽的元素都放到一个列表中。如果存在元素散列至槽i，则该槽内有个指针，指向存储所有散列到i的元素的链表的表头。链表可为单向，可为双向。

### 开放寻址法

在开放寻址中，所有的元素都存在散列表中。使用开放寻址法插入一个元素，需要连续地检查散列表，称为“探查”，直到找到一个空槽存放该元素。探查序列即为下一个需要探查地表位。常用来计算开放寻址法中的探查序列的三种方法：线性探查、二次探查和双重探查

## hashmap 源码解析

以jdk1.8为例。在jdk1.8中，当链表长度超过8时，会将其转为红黑数。影响hashmap查询效率的主要是链表的长度，使用红黑叔使其查询效率由o(n)降为o(lgn)

### 变量解释

- bucket:数组中每个可以存放元素的位置
- load factor:加载因子,衡量哈希表多满时进行自动扩容，默认0.75
- initial capacity:哈希表创建时桶的数量
- threshold:下一次进行扩容的阀值,load factor * initial capacity
- 
### 常量解释

- DEFAULT_INITIAL_CAPACITY:默认初始容量,16
- MAXIMUM_CAPACITY:最大容量,1<<30
- DEFAULT_LOAD_FACTOR:初始加载因子,0.75
- TREEIFY_THRESHOLD:由链表转为红黑树的桶的bin的数量
- UNTREEIFY_THRESHOLD:由红黑树转为链表的桶的bin的数量
- MIN_TREEIFY_CAPACITY:最小将链接转为红黑树的哈希表的容量，避免在建立初期，多个健值对恰好被放到一个链表中，导致不必要的转换。

### subclass 

#### Node<K, V>

基础的一个hash bin 的节点，也是绝大多数使用的。实现了Map.Entry接口。成员变量有hash，key，value，next。就是单向链表的节点，比较简单。

#### TreeNode<K,V>

用于tree bin（中文树容器？）。继承自LinkedHashMap.Entry<K,V>，它又继承自HashMap.Node<K,V>。成员变量除了有hash，key，value，next，还有be for，after，parent，left，right，prev。但是before与after继承自LinkedHashMap.Entry<K,V>并未使用。<br>

TreeNode的出现是因为在jdk1.8的更新中HashMap引入了红黑树，提高了查询的效率，这个也会在后面的解析中说到。


## 小tips

在阅读源码时，也看到一些有意思的地方，列在下面

- (n - 1) & hash 对hash值对于数组长度进行取余，等价于 hash ％ n 位运算效率更高，n的大小为2的指数，所以（n - 1）的二进制为11...11，与hash值做与运算即对其求余。
